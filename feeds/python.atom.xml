<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Let's tame that python together - Python</title><link href="https://steampunkislande.github.io/" rel="alternate"></link><link href="https://steampunkislande.github.io/feeds/python.atom.xml" rel="self"></link><id>https://steampunkislande.github.io/</id><updated>2021-12-28T01:00:00+01:00</updated><entry><title>Les lambda expressions en python</title><link href="https://steampunkislande.github.io/les-lambda-expressions-en-python.html" rel="alternate"></link><published>2021-12-25T23:00:00+01:00</published><updated>2021-12-28T01:00:00+01:00</updated><author><name>Charles Monod-Broca</name></author><id>tag:steampunkislande.github.io,2021-12-25:/les-lambda-expressions-en-python.html</id><summary type="html">&lt;h1&gt;Les lambda expressions en python&lt;/h1&gt;
&lt;p&gt;Ceci est le premier article de mon blog, et aujourd'hui je voulais vous partager mon expérience avec les lambda expressions en python.&lt;/p&gt;
&lt;h2&gt;Présentation&lt;/h2&gt;
&lt;p&gt;Cette syntaxe très pratique permet de créer des objets "appelables" sans définir une fonction entière, pour peu que le code a exécuter …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Les lambda expressions en python&lt;/h1&gt;
&lt;p&gt;Ceci est le premier article de mon blog, et aujourd'hui je voulais vous partager mon expérience avec les lambda expressions en python.&lt;/p&gt;
&lt;h2&gt;Présentation&lt;/h2&gt;
&lt;p&gt;Cette syntaxe très pratique permet de créer des objets "appelables" sans définir une fonction entière, pour peu que le code a exécuter tienne en une ligne.&lt;/p&gt;
&lt;p&gt;Exemple, avec une fonction qui renvoie deux fois la valeur de son unique paramètre. Avec une fonction:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Avec une lambda expression:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Quelques différences:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;La lambda expression tient en une seule ligne (alors que définir une fonction demande toujours au minimum deux lignes)&lt;/li&gt;
&lt;li&gt;Dans une lambda expression, pas de mot-clé return: le résultat à droite des &lt;code&gt;:&lt;/code&gt; &lt;strong&gt;est&lt;/strong&gt; sa valeur de retour. Plus simple ;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pour utiliser une lambda expression, pas besoin de lui donner un nom: on peut simplement la définir, et la passer en paramètre d'une fonction sans jamais la nommer. C'est pourquoi elles sont souvent appelées fonctions anonymes dans la littérature. Cependant, pas de nom à la déclaration ne veut pas dire pas de nom tout court: il faut de toutes façons lui associer une variable ne serait-ce que pour y faire référence. Donc une fonction qui prend un appelable en paramètre, si on lui passe une lambda, elle y fera référence par le nom du paramètre concerné (voir exemple ci-dessous).&lt;/p&gt;
&lt;h2&gt;À quoi servent-elles ?&lt;/h2&gt;
&lt;p&gt;Le cas typique, c'est quand on travaille avec des itérables (liste, tuple, dictionnaire, générateur...).&lt;/p&gt;
&lt;p&gt;Prenons cette liste: &lt;code&gt;l = [("Alice",45), ("Bob",30), ("Charles",12)]&lt;/code&gt;.
Chaque élément de cette liste est un tuple, sous la forme &lt;code&gt;(Prénom, Âge)&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Mais comment trier cette liste ? Si on ne précise pas, python s'en sort quand même:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Charles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Bob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Alice&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Résultat:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Alice&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Charles&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Comme vous pouvez constater, la liste est triée uniquement selon le premier élément de chaque tuple.
Et en cas d'égalité (par exemple si on compare (0,10) et (0,5)), python compare le champ suivant de chaque élément à départager. Dans le cas où on veut comparer (0,10) à (0,5), cela revient à comparer 10 et 5.&lt;/p&gt;
&lt;p&gt;Mais que viennent faire les lambdas dans tout ça ? Eh bien, si vous voulez trier selon le second élément uniquement, il suffit de passer un "appelable" à la fonction sorted. Voyez plutôt:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Charles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Bob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Alice&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Résultat:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Charles&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Alice&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ici, on a passé une lambda expression à la fonction &lt;code&gt;sorted&lt;/code&gt;. Cette dernière va donc utiliser cet "appelable" comme clé pour comparer les éléments de l.
L'idée est que &lt;code&gt;sorted&lt;/code&gt; va appeler son paramètre &lt;code&gt;key&lt;/code&gt; à chaque fois qu'elle aura besoin de comparer deux éléments. Elle appellera cette fonction avec l'élément "brut" en paramètre, en s'attendant à recevoir une valeur qui lui permettra de réellement comparer les éléments entre eux.&lt;/p&gt;
&lt;p&gt;On aurait tout à fait pu passer par une fonction d'ailleurs. Et pour voir ce qui se passe derrière tout ça, je vous propose cette fonction un peu bavarde:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;my_key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Fonction key appelée avec &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Charles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Bob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Alice&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;my_key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Cette fonction le dit à chaque fois qu'elle est appelée, ce qui nous permet de suivre son utilisation.&lt;/p&gt;
&lt;p&gt;Résultat:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Fonction&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="n"&gt;appelée&lt;/span&gt; &lt;span class="n"&gt;avec&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Charles&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Fonction&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="n"&gt;appelée&lt;/span&gt; &lt;span class="n"&gt;avec&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Fonction&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="n"&gt;appelée&lt;/span&gt; &lt;span class="n"&gt;avec&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Alice&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Sortie&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Alice&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Charles&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Comme vous pouvez l'observer, le paramètre &lt;code&gt;key&lt;/code&gt; est appelé pour chaque élément de la liste. Bien sûr, si la liste est plus longue, la fonction sera appelée à chaque fois qu'une comparaison sera nécessaire, et le nombre d'appels dépendra directement de la complexité algorithmique de la fonction de tri. Mais ce n'est pas le sujet de cet article !&lt;/p&gt;
&lt;h2&gt;Les erreurs que vous pourriez rencontrer...&lt;/h2&gt;
&lt;p&gt;Maintenant que vous savez comment utiliser une lambda expression, vous allez probablement vouloir en mettre partout. Malheureusement, dans certains cas, vous pourriez vous retrouver avec un résultat complètement inattendu. Mieux vaut prévenir que guérir, donc. Et voici une situation typique dont j'ai pu faire les frais en participant au développement de cutevariant.&lt;/p&gt;
&lt;p&gt;Considérez ce morceau de code en python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Déclarer un dictionnaire vide&lt;/span&gt;
&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Assigne à la clé i une lambda expression qui affiche i.&lt;/span&gt;
    &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Que fait ce code, et pourquoi ne ferait-il pas ce qu'on attend de lui ?
À première vue, d est un dictionnaire dont les clés sont des entiers (de 0 à 9), et les valeurs de simples lambda expressions. Intuitivement, on pourrait penser que &lt;code&gt;print(i)&lt;/code&gt; devrait afficher la même valeur que la clé à laquelle l'expression lambda est associée. Vraiment, il n'y a aucune raison...&lt;/p&gt;
&lt;p&gt;Essayons:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]()&lt;/span&gt;
&lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]()&lt;/span&gt;
&lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]()&lt;/span&gt;
&lt;span class="mi"&gt;9&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ce qui s'est passé est plutôt clair, python évalue toutes les lambdas qui font référence à la variable &lt;code&gt;i&lt;/code&gt; avec la dernière valeur qu'elle a prise...
Et malheureusement, ce comportement est parfaitement normal pour une simple lambda expression. En effet, en python, les lambda expressions sont incapables de capturer les variables locales au moment de leur déclaration ! Dans notre exemple, tout se passe comme si python évaluait la lambda expression une fois la déclaration terminée. &lt;/p&gt;
&lt;p&gt;Mais commment contourner ce problème, me demanderez-vous ?&lt;/p&gt;
&lt;h2&gt;... Et comment les corriger&lt;/h2&gt;
&lt;p&gt;Reprenons l'exemple plus haut.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Déclarer un dictionnaire vide&lt;/span&gt;
&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Assigne à la clé i une lambda expression qui affiche i.&lt;/span&gt;
    &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;En réalité, dans la plupart des cas que j'ai rencontrés, j'avais besoin de garder un registre des "appelables" existants, et de leur dire pourquoi/par qui ils ont été appelés (grâce à un numéro ou à un nom). &lt;code&gt;d&lt;/code&gt; sert donc ici de registre dans la démonstration, et la lambda expression est ce fameux "appelable".
Le rôle de &lt;code&gt;d&lt;/code&gt; est donc d'associer une clé à un "appelable".&lt;/p&gt;
&lt;p&gt;Maintenant, voici une solution possible afin que chaque "appelable" recoive la valeur qui leur est associée.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;
&lt;span class="c1"&gt;# Déclarer un dictionnaire vide&lt;/span&gt;
&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Assigne à la clé i une lambda expression qui affiche i.&lt;/span&gt;
    &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Un &lt;code&gt;partial&lt;/code&gt;, c'est un "appelable" qui prépare un appel de fonction. Par exemple, vous voulez capturer la valeur d'une variable locale à un instant t. Mais vous voulez appeler la fonction plus tard. Premier paramètre de partial: la fonction. Chaque argument supplémentaire de partial sera passé en argument à la fonction que vous voulez appeler à la fin. Vous pouvez aussi passez des arguments nommés, dans ce cas l'ordre n'a aucune importance (tant que la fonction à appeler est le premier argument de partial).&lt;/p&gt;
&lt;p&gt;Un dessin vaut mieux qu'un long discours:&lt;/p&gt;
&lt;p&gt;&lt;img alt="How partial is used" src="../images/lambda_expressions_partial.png"&gt;&lt;/p&gt;
&lt;p&gt;Voilà ! Maintenant, vous savez comment utiliser les lambda expressions et éviter les pièges !
J'espère que cet article vous aura été utile, et si vous avez des questions n'hésitez pas à ouvrir une issue sur &lt;a href="https://github.com/SteampunkIslande/blog/issues" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="GitHub"&gt;GitHub&lt;/a&gt; (C'est moins casse-pied que d'installer Disqus, peut-être plus tard).&lt;/p&gt;</content><category term="Python"></category><category term="lambda"></category><category term="common issues"></category></entry></feed>